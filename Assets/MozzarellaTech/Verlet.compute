// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel PointsMain
#include "UnityCG.cginc"
Texture2D<float4> _DepthTexture;
float4x4 _WorldToCamera;
float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;
float4x4 _CameraProjection;
float4x4 _ViewProjection;
float _NearClipValue;
float _FarClipValue;

struct Point {
    float3 position;
    float3 prevPosition;
    float3 savedPosition;
    float volume;
};

float3 _Gravity;

float3 _SquirtPosition;
float3 _SquirtVelocity;
float _SquirtVolume;
uint _SquirtIndex;

float _DeltaTime;
float _Length;
uint _NumParticles;

RWStructuredBuffer<Point> _Points;

float hash13(float3 p3) {
	p3 = frac(p3 * .1031);
    p3 += dot(p3, p3.zyx + 31.32);
    return frac((p3.x + p3.y) * p3.z);
}
void StartPointCalc(inout Point p) {
    p.savedPosition = p.position;
}
void FinishPointCalc(inout Point p) {
    p.prevPosition = p.savedPosition;
}

void ComputePoint(inout Point p) {
    p.position += (p.position - p.prevPosition)*0.99;
    p.position += _Gravity * _DeltaTime * _DeltaTime;
    //p.position.y = max(p.position.y,0);
}


void DepthCollide(inout Point p) {
    // World position -> [0,1) camera space
    uint width, height;
    _DepthTexture.GetDimensions(width, height);

    // Need the full view projection matrix to figure out where the point lays in texture space.
    float4 uv = mul(_ViewProjection, float4(p.position,1));
    uv = uv/uv.w;
    float2 realuv = float2(uv.xy)*0.5+0.5;
    if (realuv.x < 0 || realuv.y < 0 || realuv.y > 1 || realuv.x > 1) {
        return;
    }

    // This is how I correct for depth buffer ray distortion, there's probably a more efficent way
    float4 viewVector = mul(_CameraInverseProjection, float4(uv.xy, 0, -1));
    float3 rayLength = mul(_CameraToWorld, float4(viewVector.xyz,0)).xyz;
    // Of course, textures in compute shaders don't take normalized uvs, so we need the screen size...
    float nonlin_depth = _DepthTexture[realuv*uint2(width,height)].r;

    // the start and end clipping plane have fucked up depth data, so we try to ignore it.
    if (nonlin_depth == 0 || nonlin_depth == 1) {
        return;
    }

    float screenDist = LinearEyeDepth(nonlin_depth) * length(rayLength);

    float3 camWS = mul(_CameraToWorld, float4(0,0,0,1)).xyz;
    float3 dir = p.position-camWS;
    if (screenDist < length(dir)) {
        p.position = (normalize(dir)*screenDist)+camWS;
        p.prevPosition = p.position;
        p.savedPosition = p.position;
    }
}

void ComputeStick(inout Point a, Point b) {
    float3 stickCenter = (a.position + b.position)*0.5;
    float3 stickDir = normalize(a.position - b.position);
    a.position = lerp(a.position, stickCenter + stickDir * _Length * 0.5, saturate(a.volume*b.volume*1000));
}

[numthreads(64,1,1)]
void PointsMain (uint3 id : SV_DispatchThreadID) {
    if (id.x == _SquirtIndex) {
        _Points[id.x].prevPosition = _SquirtPosition-_SquirtVelocity;
        _Points[id.x].position = _SquirtPosition;
        _Points[id.x].volume = _SquirtVolume;
        int lastID = (id.x+1)%_NumParticles;
        _Points[lastID].volume = 0;
    }
    StartPointCalc(_Points[id.x]);
    DepthCollide(_Points[id.x]);
    ComputePoint(_Points[id.x]);
    ComputeStick(_Points[id.x], _Points[(id.x+1)%(_NumParticles)]);
    ComputeStick(_Points[id.x], _Points[(id.x-1+_NumParticles)%(_NumParticles)]);
    FinishPointCalc(_Points[id.x]);
}